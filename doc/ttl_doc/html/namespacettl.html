<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TTL: The Triangulation Template Library</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<div class="qindex">
<a class="qindexHL" href="index.html">Main&nbsp;Page</a> | 
<a class="qindex" href="namespaces.html">Namespace List</a> | 
<a class="qindex" href="files.html">File&nbsp;List</a> | 
<a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | 
<a class="qindex" href="pages.html">Related&nbsp;Pages</a>
</div>
</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<h1>ttl Namespace Reference</h1>Main interface to TTL.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Delaunay Triangulation</div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class DartType, class PointType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#29dbf8ff663e9cbccec2ed17d437b915">insertNode</a> (DartType &amp;dart, PointType &amp;point)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a00031d9430d34aebf644083efb41949"></a><!-- doxytag: member="ttl::insertNodes" ref="a00031d9430d34aebf644083efb41949" args="(ForwardIterator first, ForwardIterator last, DartType &amp;dart)" -->
template&lt;class TraitsType, class ForwardIterator, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#a00031d9430d34aebf644083efb41949">insertNodes</a> (ForwardIterator first, ForwardIterator last, DartType &amp;dart)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#41f7533eb14dea5b7c3f4c6ea7f16655">removeRectangularBoundary</a> (DartType &amp;dart)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#796193050d5583c4f96f9f6bd988e530">removeNode</a> (DartType &amp;dart)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#4c3b043409ba7cdf81b2735178e5515b">removeBoundaryNode</a> (DartType &amp;dart)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#cf9077871a0528b08ad66273c3e097a4">removeInteriorNode</a> (DartType &amp;dart)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Topological and Geometric Queries</div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a40c505f5c644357ef7fa7832c75f72d"></a><!-- doxytag: member="ttl::isMemberOfFace" ref="a40c505f5c644357ef7fa7832c75f72d" args="(const TopologyElementType &amp;topologyElement, const DartType &amp;dart)" -->
template&lt;class TopologyElementType, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#a40c505f5c644357ef7fa7832c75f72d">isMemberOfFace</a> (const TopologyElementType &amp;topologyElement, const DartType &amp;dart)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f0501eebc04d7de800796da518c1d725"></a><!-- doxytag: member="ttl::locateFaceWithNode" ref="f0501eebc04d7de800796da518c1d725" args="(const NodeType &amp;node, DartType &amp;dart_iter)" -->
template&lt;class TraitsType, class NodeType, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#f0501eebc04d7de800796da518c1d725">locateFaceWithNode</a> (const NodeType &amp;node, DartType &amp;dart_iter)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class PointType, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#777fd45858e655ab8fb244def6310800">locateFaceSimplest</a> (const PointType &amp;point, DartType &amp;dart)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class PointType, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#5f04c20d0786755a92c8d2f166379599">locateTriangle</a> (const PointType &amp;point, DartType &amp;dart)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class PointType, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#ca779a1542007963c85671739b834b2f">inTriangleSimplest</a> (const PointType &amp;point, const DartType &amp;dart)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class PointType, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#bb59c1837c69f524f6b420de5c70e590">inTriangle</a> (const PointType &amp;point, const DartType &amp;dart)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="1fb9cc6b4fdf12601dcc32cec5eefcae"></a><!-- doxytag: member="ttl::getAdjacentTriangles" ref="1fb9cc6b4fdf12601dcc32cec5eefcae" args="(const DartType &amp;dart, DartType &amp;t1, DartType &amp;t2, DartType &amp;t3)" -->
template&lt;class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#1fb9cc6b4fdf12601dcc32cec5eefcae">getAdjacentTriangles</a> (const DartType &amp;dart, DartType &amp;t1, DartType &amp;t2, DartType &amp;t3)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DartType, class DartListType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#0ec704f9c10a79e00e4765388259cbc0">getBoundary</a> (const DartType &amp;dart, DartListType &amp;boundary)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#0005ecaf3d54298da01be64ea6b474a8">isBoundaryEdge</a> (const DartType &amp;dart)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#f02d63e99753db4e1259205a3ccb8432">isBoundaryFace</a> (const DartType &amp;dart)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#9eba6026cb5037c2e9ad5d203c1257ab">isBoundaryNode</a> (const DartType &amp;dart)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#6b6626cfe11df135e5f9f64bb6887a8a">getDegreeOfNode</a> (const DartType &amp;dart)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="dda737818f8e2fc111661d8bd060050e"></a><!-- doxytag: member="ttl::getNeighborNodes" ref="dda737818f8e2fc111661d8bd060050e" args="(const DartType &amp;dart, list&lt; DartType &gt; &amp;node_list, bool &amp;boundary)" -->
template&lt;class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#dda737818f8e2fc111661d8bd060050e">getNeighborNodes</a> (const DartType &amp;dart, list&lt; DartType &gt; &amp;node_list, bool &amp;boundary)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DartType, class DartListType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#0b7770fa904a92f88d04bf6c72678bd5">get_0_orbit_interior</a> (const DartType &amp;dart, DartListType &amp;orbit)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DartType, class DartListType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#92d5a9e73a19455c4ca1df9bda3bb2fd">get_0_orbit_boundary</a> (const DartType &amp;dart, DartListType &amp;orbit)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#6cfdc49c5fc77db106f8ab2aebbdde2c">same_0_orbit</a> (const DartType &amp;d1, const DartType &amp;d2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#ba7626e4155dc165219a5f6e49fbb4b1">same_1_orbit</a> (const DartType &amp;d1, const DartType &amp;d2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#57597fbf403410ffec959aba5f52c5ef">same_2_orbit</a> (const DartType &amp;d1, const DartType &amp;d2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="bbb58a1e5f752fff8ebdca106949f2f5"></a><!-- doxytag: member="ttl::degenerateTriangle" ref="bbb58a1e5f752fff8ebdca106949f2f5" args="(const DartType &amp;dart)" -->
template&lt;class TraitsType, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#bbb58a1e5f752fff8ebdca106949f2f5">degenerateTriangle</a> (const DartType &amp;dart)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#415ce5b4cf222358687f5edff7a11d52">swappableEdge</a> (const DartType &amp;dart, bool allowDegeneracy=false)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#1ebe9935cf27a446e515c3b0922d7c1e">positionAtNextBoundaryEdge</a> (DartType &amp;dart)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#9e0e563f94040b05ebda955e4bb74028">convexBoundary</a> (const DartType &amp;dart)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Utilities for Delaunay Triangulation</div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class DartType, class DartListType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#190da335d29a65ce524868714ff3614c">optimizeDelaunay</a> (DartListType &amp;elist)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="cd26a196905132b99ef67f10ec7162d7"></a><!-- doxytag: member="ttl::optimizeDelaunay" ref="cd26a196905132b99ef67f10ec7162d7" args="(DartListType &amp;elist, const typename DartListType::iterator end)" -->
template&lt;class TraitsType, class DartType, class DartListType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#cd26a196905132b99ef67f10ec7162d7">optimizeDelaunay</a> (DartListType &amp;elist, const typename DartListType::iterator end)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#1cb871915e3fbcf5f4e25079a7500f0c">swapTestDelaunay</a> (const DartType &amp;dart, bool cycling_check)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#34b5791cd85eef9043f80f859b53b24c">recSwapDelaunay</a> (DartType &amp;diagonal)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class DartType, class ListType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#cc25203893aa640fe9f66b28d84e457d">swapEdgesAwayFromInteriorNode</a> (DartType &amp;dart, ListType &amp;swapped_edges)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class DartType, class ListType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#b862634af9ce8c71497dc78993104cbf">swapEdgesAwayFromBoundaryNode</a> (DartType &amp;dart, ListType &amp;swapped_edges)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class DartType, class DartListType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#816c0b9687712b9a58225c46fbaa8446">swapEdgeInList</a> (const typename DartListType::iterator &amp;it, DartListType &amp;elist)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Constrained (Delaunay) Triangulation</div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TraitsType, class DartType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">DartType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacettl.html#3096f6756146df27c873c4ff3fe5a19f">insertConstraint</a> (DartType &amp;dstart, DartType &amp;dend, bool optimize_delaunay)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This namespace contains the basic generic algorithms for the TTL, the Triangulation Template Library.<br>
<p>
Examples of functionality are:<ul>
<li>Incremental Delaunay triangulation</li><li>Constrained triangulation</li><li>Insert/remove nodes and constrained edges</li><li>Traversal operations</li><li>Misc. queries for extracting information for visualisation systems etc.</li></ul>
<p>
<dl class="user" compact><dt><b>General requirements and assumptions:</b></dt><dd><ul>
<li><em>DartType</em> and <em>TraitsType</em> should be implemented in accordance with the description in <a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/api.html">Application Programming Interface to TTL (API)</a>.</li><li>A <b>"Requires:"</b> section in the documentation of a function template shows which functionality is required in <em>TraitsType</em> to support that specific function.<br>
 Functionalty required in <em>DartType</em> is the same (almost) for all function templates; see <a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/api.html">Application Programming Interface to TTL (API)</a> and the example referred to.</li><li>When a reference to a <em>dart</em> object is passed to a function in TTL, it is assumed that it is oriented <em>counterclockwise</em> (CCW) in a triangle unless it is explicitly mentioned that it can also be <em>clockwise</em> (CW). The same applies for a dart that is passed from a function in TTL to the users TraitsType class (or struct).</li><li>When an edge (represented with a dart) is swapped, it is assumed that darts outside the quadrilateral where the edge is a diagonal are not affected by the swap. Thus, <a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#b90cf64bafd25ff741c1bcd993c07273">TraitsType::swapEdge</a> must be implemented in accordance with this rule.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Glossary:</b></dt><dd><ul>
<li>General terms are explained in <a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/api.html">Application Programming Interface to TTL (API)</a>.</li><li><em>CCW</em> - counterclockwise</li><li><em>CW</em> - clockwise</li><li><em>0_orbit</em>, <em>1_orbit</em> and <em>2_orbit</em>: A sequence of darts around a node, around an edge and in a triangle respectively; see <a class="el" href="namespacettl.html#0b7770fa904a92f88d04bf6c72678bd5">ttl::get_0_orbit_interior</a> and <a class="el" href="namespacettl.html#92d5a9e73a19455c4ca1df9bda3bb2fd">ttl::get_0_orbit_boundary</a></li><li><em>arc</em> - In a triangulation an arc is equivalent with an edge</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacettl__util.html">ttl_util</a> and <a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/api.html">Application Programming Interface to TTL (API)</a></dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Øyvind Hjelle, <a href="mailto:oyvindhj@ifi.uio.no">oyvindhj@ifi.uio.no</a> </dd></dl>

<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="29dbf8ff663e9cbccec2ed17d437b915"></a><!-- doxytag: member="ttl::insertNode" ref="29dbf8ff663e9cbccec2ed17d437b915" args="(DartType &amp;dart, PointType &amp;point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ttl::insertNode           </td>
          <td>(</td>
          <td class="paramtype">DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts a new node in an existing Delaunay triangulation and swaps edges to obtain a new Delaunay triangulation. This is the basic function for incremental Delaunay triangulation. When starting from a set of points, an initial Delaunay triangulation can be created as two triangles forming a rectangle that contains all the points. After <code>insertNode</code> has been called repeatedly with all the points, <a class="el" href="namespacettl.html#41f7533eb14dea5b7c3f4c6ea7f16655">ttl::removeRectangularBoundary</a> can be called to remove triangles at the boundary of the triangulation so that the boundary form the convex hull of the points.<p>
Note that this incremetal scheme will run much faster if the points have been sorted lexicographically on <em>x</em> and <em>y</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dart</em>&nbsp;</td><td>An arbitrary CCW dart in the tringulation.<br>
 Output: A CCW dart incident to the new node.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>A point (node) to be inserted in the triangulation.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bool</em>&nbsp;</td><td><code>true</code> if <em>point</em> was inserted; <code>false</code> if not.<br>
 If <em>point</em> is outside the triangulation, or the input dart is not valid, <code>false</code> is returned.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#30c22ae7837e750566956fd9c4a746b3">TraitsType::splitTriangle</a> (DartType&amp;, const PointType&amp;)</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Using:</b></dt><dd><ul>
<li><a class="el" href="namespacettl.html#5f04c20d0786755a92c8d2f166379599">ttl::locateTriangle</a></li><li><a class="el" href="namespacettl.html#34b5791cd85eef9043f80f859b53b24c">ttl::recSwapDelaunay</a></li></ul>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><ul>
<li>For efficiency reasons <em>dart</em> should be close to the insertion <em>point</em>.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacettl.html#41f7533eb14dea5b7c3f4c6ea7f16655">ttl::removeRectangularBoundary</a> </dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l00268">268</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="41f7533eb14dea5b7c3f4c6ea7f16655"></a><!-- doxytag: member="ttl::removeRectangularBoundary" ref="41f7533eb14dea5b7c3f4c6ea7f16655" args="(DartType &amp;dart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ttl::removeRectangularBoundary           </td>
          <td>(</td>
          <td class="paramtype">DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the rectangular boundary of a triangulation as a final step of an incremental Delaunay triangulation. The four nodes at the corners will be removed and the resulting triangulation will have a convex boundary and be Delaunay.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dart</em>&nbsp;</td><td>A CCW dart at the boundary of the triangulation<br>
 Output: A CCW dart at the new boundary</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Using:</b></dt><dd><ul>
<li><a class="el" href="namespacettl.html#4c3b043409ba7cdf81b2735178e5515b">ttl::removeBoundaryNode</a></li></ul>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><ul>
<li>This function requires that the boundary of the triangulation is a rectangle with four nodes (one in each corner). </li></ul>
</dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l00352">352</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="796193050d5583c4f96f9f6bd988e530"></a><!-- doxytag: member="ttl::removeNode" ref="796193050d5583c4f96f9f6bd988e530" args="(DartType &amp;dart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ttl::removeNode           </td>
          <td>(</td>
          <td class="paramtype">DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the node associated with <em>dart</em> and updates the triangulation to be Delaunay.<p>
<dl class="user" compact><dt><b>Using:</b></dt><dd><ul>
<li><a class="el" href="namespacettl.html#4c3b043409ba7cdf81b2735178e5515b">ttl::removeBoundaryNode</a> if <em>dart</em> represents a node at the boundary</li><li><a class="el" href="namespacettl.html#cf9077871a0528b08ad66273c3e097a4">ttl::removeInteriorNode</a> if <em>dart</em> represents an interior node</li></ul>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><ul>
<li>The node cannot belong to a fixed (constrained) edge that is not swappable. (An endless loop is likely to occur in this case). </li></ul>
</dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l00381">381</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="4c3b043409ba7cdf81b2735178e5515b"></a><!-- doxytag: member="ttl::removeBoundaryNode" ref="4c3b043409ba7cdf81b2735178e5515b" args="(DartType &amp;dart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ttl::removeBoundaryNode           </td>
          <td>(</td>
          <td class="paramtype">DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the boundary node associated with <em>dart</em> and updates the triangulation to be Delaunay.<p>
<dl class="user" compact><dt><b>Using:</b></dt><dd><ul>
<li><a class="el" href="namespacettl.html#b862634af9ce8c71497dc78993104cbf">ttl::swapEdgesAwayFromBoundaryNode</a></li><li><a class="el" href="namespacettl.html#190da335d29a65ce524868714ff3614c">ttl::optimizeDelaunay</a></li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#ffc92413f24150dc941fd0a7323aa479">TraitsType::removeBoundaryTriangle</a> (Dart&amp;) </li></ul>
</dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l00402">402</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="cf9077871a0528b08ad66273c3e097a4"></a><!-- doxytag: member="ttl::removeInteriorNode" ref="cf9077871a0528b08ad66273c3e097a4" args="(DartType &amp;dart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ttl::removeInteriorNode           </td>
          <td>(</td>
          <td class="paramtype">DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the interior node associated with <em>dart</em> and updates the triangulation to be Delaunay.<p>
<dl class="user" compact><dt><b>Using:</b></dt><dd><ul>
<li><a class="el" href="namespacettl.html#cc25203893aa640fe9f66b28d84e457d">ttl::swapEdgesAwayFromInteriorNode</a></li><li><a class="el" href="namespacettl.html#190da335d29a65ce524868714ff3614c">ttl::optimizeDelaunay</a></li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#a587ae53ef0ed811367696ffbd7b6b07">TraitsType::reverse_splitTriangle</a> (Dart&amp;)</li></ul>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><ul>
<li>The node cannot belong to a fixed (constrained) edge that is not swappable. (An endless loop is likely to occur in this case). </li></ul>
</dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l00466">466</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="777fd45858e655ab8fb244def6310800"></a><!-- doxytag: member="ttl::locateFaceSimplest" ref="777fd45858e655ab8fb244def6310800" args="(const PointType &amp;point, DartType &amp;dart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ttl::locateFaceSimplest           </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locates the face containing a given point. It is assumed that the tessellation (e.g. a triangulation) is <em>regular</em> in the sense that there are no holes, the boundary is convex and there are no degenerate faces.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>A point to be located</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dart</em>&nbsp;</td><td>An arbitrary CCW dart in the triangulation<br>
 Output: A CCW dart in the located face</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bool</em>&nbsp;</td><td><code>true</code> if a face is found; <code>false</code> if not.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#ea241c2ba424c3c802fc0c54d6c74a0a">TraitsType::orient2d</a> (DartType&amp;, DartType&amp;, PointType&amp;)</li></ul>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><ul>
<li>If <code>false</code> is returned, <em>point</em> may still be inside a face if the tessellation is not <em>regular</em> as explained above.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacettl.html#5f04c20d0786755a92c8d2f166379599">ttl::locateTriangle</a> </dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l00587">587</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="5f04c20d0786755a92c8d2f166379599"></a><!-- doxytag: member="ttl::locateTriangle" ref="5f04c20d0786755a92c8d2f166379599" args="(const PointType &amp;point, DartType &amp;dart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ttl::locateTriangle           </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locates the triangle containing a given point. It is assumed that the triangulation is <em>regular</em> in the sense that there are no holes and the boundary is convex. This function deals with degeneracy to some extent, but round-off errors may still lead to a wrong result if triangles are degenerate.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>A point to be located</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dart</em>&nbsp;</td><td>An arbitrary CCW dart in the triangulation<br>
 Output: A CCW dart in the located triangle</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bool</em>&nbsp;</td><td><code>true</code> if a triangle is found; <code>false</code> if not.<br>
 If <em>point</em> is outside the triangulation, in which case <code>false</code> is returned, then the edge associated with <em>dart</em> will be at the boundary of the triangulation.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Using:</b></dt><dd><ul>
<li><a class="el" href="namespacettl.html#777fd45858e655ab8fb244def6310800">ttl::locateFaceSimplest</a></li><li><a class="el" href="namespacettl.html#bb59c1837c69f524f6b420de5c70e590">ttl::inTriangle</a> </li></ul>
</dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l00654">654</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="ca779a1542007963c85671739b834b2f"></a><!-- doxytag: member="ttl::inTriangleSimplest" ref="ca779a1542007963c85671739b834b2f" args="(const PointType &amp;point, const DartType &amp;dart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ttl::inTriangleSimplest           </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if <em>point</em> is inside the triangle associated with <em>dart</em>. A fast and simple function that does not deal with degeneracy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dart</em>&nbsp;</td><td>A CCW dart in the triangle</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#ea241c2ba424c3c802fc0c54d6c74a0a">TraitsType::orient2d</a> (DartType&amp;, DartType&amp;, PointType&amp;)</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacettl.html#bb59c1837c69f524f6b420de5c70e590">ttl::inTriangle</a> for a more robust function </dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l00706">706</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="bb59c1837c69f524f6b420de5c70e590"></a><!-- doxytag: member="ttl::inTriangle" ref="bb59c1837c69f524f6b420de5c70e590" args="(const PointType &amp;point, const DartType &amp;dart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ttl::inTriangle           </td>
          <td>(</td>
          <td class="paramtype">const PointType &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if <em>point</em> is inside the triangle associated with <em>dart</em>. This function deals with degeneracy to some extent, but round-off errors may still lead to wrong result if the triangle is degenerate.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dart</em>&nbsp;</td><td>A CCW dart in the triangle</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#5531879b378f97fe2b6b12e7a692bcb3">TraitsType::crossProduct2d</a> (DartType&amp;, PointType&amp;)</li><li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#17993a770acea1213bde7ef2ebed5234">TraitsType::scalarProduct2d</a> (DartType&amp;, PointType&amp;)</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacettl.html#ca779a1542007963c85671739b834b2f">ttl::inTriangleSimplest</a> </dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l00750">750</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="0ec704f9c10a79e00e4765388259cbc0"></a><!-- doxytag: member="ttl::getBoundary" ref="0ec704f9c10a79e00e4765388259cbc0" args="(const DartType &amp;dart, DartListType &amp;boundary)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ttl::getBoundary           </td>
          <td>(</td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DartListType &amp;&nbsp;</td>
          <td class="paramname"> <em>boundary</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the boundary as sequence of darts, where the edges associated with the darts are boundary edges, given a dart with an associating edge at the boundary of a topology structure. The first dart in the sequence will be the given one, and the others will have the same orientation (CCW or CW) as the first. Assumes that the given dart is at the boundary.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dart</em>&nbsp;</td><td>A dart at the boundary (CCW or CW)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boundary</em>&nbsp;</td><td>A sequence of darts, where the associated edges are the boundary edges</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li>DartListType::push_back (DartType&amp;) </li></ul>
</dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l00876">876</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="0005ecaf3d54298da01be64ea6b474a8"></a><!-- doxytag: member="ttl::isBoundaryEdge" ref="0005ecaf3d54298da01be64ea6b474a8" args="(const DartType &amp;dart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ttl::isBoundaryEdge           </td>
          <td>(</td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the edge associated with <em>dart</em> is at the boundary of the triangulation.<p>
<dl class="user" compact><dt><b>Implements:</b></dt><dd><div class="fragment"><pre class="fragment">   DartType dart_iter = dart;
   <span class="keywordflow">if</span> (dart_iter.alpha2() == dart)
     <span class="keywordflow">return</span> <span class="keyword">true</span>;
   <span class="keywordflow">else</span>
     <span class="keywordflow">return</span> <span class="keyword">false</span>;
</pre></div> </dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l00922">922</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="f02d63e99753db4e1259205a3ccb8432"></a><!-- doxytag: member="ttl::isBoundaryFace" ref="f02d63e99753db4e1259205a3ccb8432" args="(const DartType &amp;dart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ttl::isBoundaryFace           </td>
          <td>(</td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the face associated with <em>dart</em> is at the boundary of the triangulation. 
<p>
Definition at line <a class="el" href="ttl_8h-source.html#l00937">937</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="9eba6026cb5037c2e9ad5d203c1257ab"></a><!-- doxytag: member="ttl::isBoundaryNode" ref="9eba6026cb5037c2e9ad5d203c1257ab" args="(const DartType &amp;dart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ttl::isBoundaryNode           </td>
          <td>(</td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the node associated with <em>dart</em> is at the boundary of the triangulation. 
<p>
Definition at line <a class="el" href="ttl_8h-source.html#l00966">966</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="6b6626cfe11df135e5f9f64bb6887a8a"></a><!-- doxytag: member="ttl::getDegreeOfNode" ref="6b6626cfe11df135e5f9f64bb6887a8a" args="(const DartType &amp;dart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ttl::getDegreeOfNode           </td>
          <td>(</td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the degree of the node associated with <em>dart</em>.<p>
<dl class="user" compact><dt><b>Definition:</b></dt><dd>The <em>degree</em> (or valency) of a node <em>V</em> in a triangulation, is defined as the number of edges incident with <em>V</em>, i.e., the number of edges joining <em>V</em> with another node in the triangulation. </dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l00999">999</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="0b7770fa904a92f88d04bf6c72678bd5"></a><!-- doxytag: member="ttl::get_0_orbit_interior" ref="0b7770fa904a92f88d04bf6c72678bd5" args="(const DartType &amp;dart, DartListType &amp;orbit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ttl::get_0_orbit_interior           </td>
          <td>(</td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DartListType &amp;&nbsp;</td>
          <td class="paramname"> <em>orbit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the 0-orbit around an interior node.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dart</em>&nbsp;</td><td>A dart (CCW or CW) positioned at an <em>interior</em> node.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>orbit</em>&nbsp;</td><td>Sequence of darts with one orbit for each arc. All the darts have the same orientation (CCW or CW) as <em>dart</em>, and <em>dart</em> is the first element in the sequence.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li>DartListType::push_back (DartType&amp;)</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacettl.html#92d5a9e73a19455c4ca1df9bda3bb2fd">ttl::get_0_orbit_boundary</a> </dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l01124">1124</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="92d5a9e73a19455c4ca1df9bda3bb2fd"></a><!-- doxytag: member="ttl::get_0_orbit_boundary" ref="92d5a9e73a19455c4ca1df9bda3bb2fd" args="(const DartType &amp;dart, DartListType &amp;orbit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ttl::get_0_orbit_boundary           </td>
          <td>(</td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DartListType &amp;&nbsp;</td>
          <td class="paramname"> <em>orbit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the 0-orbit around a node at the boundary<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dart</em>&nbsp;</td><td>A dart (CCW or CW) positioned at a <em>boundary</em> <em>node</em> and at a <em>boundary</em> <em>edge</em>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>orbit</em>&nbsp;</td><td>Sequence of darts with one orbit for each arc. All the darts, <em>exept</em> <em>the</em> <em>last</em> one, have the same orientation (CCW or CW) as <em>dart</em>, and <em>dart</em> is the first element in the sequence.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li>DartListType::push_back (DartType&amp;)</li></ul>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><ul>
<li>The last dart in the sequence have opposite orientation compared to the others!</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacettl.html#0b7770fa904a92f88d04bf6c72678bd5">ttl::get_0_orbit_interior</a> </dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l01158">1158</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="6cfdc49c5fc77db106f8ab2aebbdde2c"></a><!-- doxytag: member="ttl::same_0_orbit" ref="6cfdc49c5fc77db106f8ab2aebbdde2c" args="(const DartType &amp;d1, const DartType &amp;d2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ttl::same_0_orbit           </td>
          <td>(</td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>d2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the two darts belong to the same 0-orbit, i.e., if they share a node. <em>d1</em> and/or <em>d2</em> can be CCW or CW.<p>
(This function also examines if the the node associated with <em>d1</em> is at the boundary, which slows down the function (slightly). If it is known that the node associated with <em>d1</em> is an interior node and a faster version is needed, the user should implement his/her own version.) 
<p>
Definition at line <a class="el" href="ttl_8h-source.html#l01185">1185</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="ba7626e4155dc165219a5f6e49fbb4b1"></a><!-- doxytag: member="ttl::same_1_orbit" ref="ba7626e4155dc165219a5f6e49fbb4b1" args="(const DartType &amp;d1, const DartType &amp;d2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ttl::same_1_orbit           </td>
          <td>(</td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>d2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the two darts belong to the same 1-orbit, i.e., if they share an edge. <em>d1</em> and/or <em>d2</em> can be CCW or CW. 
<p>
Definition at line <a class="el" href="ttl_8h-source.html#l01219">1219</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="57597fbf403410ffec959aba5f52c5ef"></a><!-- doxytag: member="ttl::same_2_orbit" ref="57597fbf403410ffec959aba5f52c5ef" args="(const DartType &amp;d1, const DartType &amp;d2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ttl::same_2_orbit           </td>
          <td>(</td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>d2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the two darts belong to the same 2-orbit, i.e., if they lie in the same triangle. <em>d1</em> and/or <em>d2</em> can be CCW or CW 
<p>
Definition at line <a class="el" href="ttl_8h-source.html#l01235">1235</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="415ce5b4cf222358687f5edff7a11d52"></a><!-- doxytag: member="ttl::swappableEdge" ref="415ce5b4cf222358687f5edff7a11d52" args="(const DartType &amp;dart, bool allowDegeneracy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ttl::swappableEdge           </td>
          <td>(</td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allowDegeneracy</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the edge associated with <em>dart</em> is swappable, i.e., if the edge is a diagonal in a <em>strictly</em> convex (or convex) quadrilateral.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>allowDegeneracy</em>&nbsp;</td><td>If set to true, the function will also return true if the numerical calculations indicate that the quadrilateral is convex only, and not necessarily strictly convex.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#5531879b378f97fe2b6b12e7a692bcb3">TraitsType::crossProduct2d</a> (Dart&amp;, Dart&amp;) </li></ul>
</dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l01277">1277</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="1ebe9935cf27a446e515c3b0922d7c1e"></a><!-- doxytag: member="ttl::positionAtNextBoundaryEdge" ref="1ebe9935cf27a446e515c3b0922d7c1e" args="(DartType &amp;dart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ttl::positionAtNextBoundaryEdge           </td>
          <td>(</td>
          <td class="paramtype">DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a <em>dart</em>, CCW or CW, positioned in a 0-orbit at the boundary of a tessellation. Position <em>dart</em> at a boundary edge in the same 0-orbit.<br>
 If the given <em>dart</em> is CCW, <em>dart</em> is positioned at the left boundary edge and will be CW.<br>
 If the given <em>dart</em> is CW, <em>dart</em> is positioned at the right boundary edge and will be CCW.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><ul>
<li>The given <em>dart</em> must have a source node at the boundary, otherwise an infinit loop occurs. </li></ul>
</dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l01330">1330</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="9e0e563f94040b05ebda955e4bb74028"></a><!-- doxytag: member="ttl::convexBoundary" ref="9e0e563f94040b05ebda955e4bb74028" args="(const DartType &amp;dart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ttl::convexBoundary           </td>
          <td>(</td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the boundary of a triangulation is convex.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dart</em>&nbsp;</td><td>A CCW dart at the boundary of the triangulation</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#5531879b378f97fe2b6b12e7a692bcb3">TraitsType::crossProduct2d</a> (const Dart&amp;, const Dart&amp;) </li></ul>
</dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l01355">1355</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="190da335d29a65ce524868714ff3614c"></a><!-- doxytag: member="ttl::optimizeDelaunay" ref="190da335d29a65ce524868714ff3614c" args="(DartListType &amp;elist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ttl::optimizeDelaunay           </td>
          <td>(</td>
          <td class="paramtype">DartListType &amp;&nbsp;</td>
          <td class="paramname"> <em>elist</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Optimizes the edges in the given sequence according to the <em>Delaunay</em> criterion, i.e., such that the edge will fullfill the <em>circumcircle</em> criterion (or equivalently the <em>MaxMin</em> angle criterion) with respect to the quadrilaterals where they are diagonals.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>elist</em>&nbsp;</td><td>The sequence of edges</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#b90cf64bafd25ff741c1bcd993c07273">TraitsType::swapEdge</a> (DartType&amp; <em>dart</em>)<br>
 <b>Note:</b> Must be implemented such that <em>dart</em> is delivered back in a position as seen if it was glued to the edge when swapping (rotating) the edge CCW</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Using:</b></dt><dd><ul>
<li><a class="el" href="namespacettl.html#1cb871915e3fbcf5f4e25079a7500f0c">ttl::swapTestDelaunay</a> </li></ul>
</dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l01420">1420</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="1cb871915e3fbcf5f4e25079a7500f0c"></a><!-- doxytag: member="ttl::swapTestDelaunay" ref="1cb871915e3fbcf5f4e25079a7500f0c" args="(const DartType &amp;dart, bool cycling_check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ttl::swapTestDelaunay           </td>
          <td>(</td>
          <td class="paramtype">const DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>cycling_check</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the edge associated with <em>dart</em> should be swapped according to the <em>Delaunay</em> criterion, i.e., the <em>circumcircle</em> criterion (or equivalently the <em>MaxMin</em> angle criterion).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cycling_check</em>&nbsp;</td><td>Must be set to <code>true</code> when used in connection with optimization algorithms, e.g., optimizeDelaunay. This will avoid cycling and infinite loops in nearly neutral cases.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#17993a770acea1213bde7ef2ebed5234">TraitsType::scalarProduct2d</a> (DartType&amp;, DartType&amp;)</li><li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#5531879b378f97fe2b6b12e7a692bcb3">TraitsType::crossProduct2d</a> (DartType&amp;, DartType&amp;) </li></ul>
</dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l01493">1493</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="34b5791cd85eef9043f80f859b53b24c"></a><!-- doxytag: member="ttl::recSwapDelaunay" ref="34b5791cd85eef9043f80f859b53b24c" args="(DartType &amp;diagonal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ttl::recSwapDelaunay           </td>
          <td>(</td>
          <td class="paramtype">DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>diagonal</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursively swaps edges in the triangulation according to the <em>Delaunay</em> criterion.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>diagonal</em>&nbsp;</td><td>A CCW dart representing the edge where the recursion starts from.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#b90cf64bafd25ff741c1bcd993c07273">TraitsType::swapEdge</a> (DartType&amp;)<br>
 <b>Note:</b> Must be implemented such that the darts outside the quadrilateral are not affected by the swap.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Using:</b></dt><dd><ul>
<li>Calls itself recursively </li></ul>
</dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l01605">1605</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="cc25203893aa640fe9f66b28d84e457d"></a><!-- doxytag: member="ttl::swapEdgesAwayFromInteriorNode" ref="cc25203893aa640fe9f66b28d84e457d" args="(DartType &amp;dart, ListType &amp;swapped_edges)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ttl::swapEdgesAwayFromInteriorNode           </td>
          <td>(</td>
          <td class="paramtype">DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ListType &amp;&nbsp;</td>
          <td class="paramname"> <em>swapped_edges</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps edges away from the (interior) node associated with <em>dart</em> such that that exactly three edges remain incident with the node. This function is used as a first step in <a class="el" href="namespacettl.html#cf9077871a0528b08ad66273c3e097a4">ttl::removeInteriorNode</a><p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dart</em>&nbsp;</td><td>A CCW dart incident with the node</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumes:</b></dt><dd><ul>
<li>The node associated with <em>dart</em> is interior to the triangulation.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#b90cf64bafd25ff741c1bcd993c07273">TraitsType::swapEdge</a> (DartType&amp; <em>dart</em>)<br>
 <b>Note:</b> Must be implemented such that <em>dart</em> is delivered back in a position as seen if it was glued to the edge when swapping (rotating) the edge CCW</li></ul>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><ul>
<li>A degenerate triangle may be left at the node.</li><li>The function is not unique as it depends on which dart at the node that is given as input.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacettl.html#b862634af9ce8c71497dc78993104cbf">ttl::swapEdgesAwayFromBoundaryNode</a> </dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l01670">1670</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="b862634af9ce8c71497dc78993104cbf"></a><!-- doxytag: member="ttl::swapEdgesAwayFromBoundaryNode" ref="b862634af9ce8c71497dc78993104cbf" args="(DartType &amp;dart, ListType &amp;swapped_edges)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ttl::swapEdgesAwayFromBoundaryNode           </td>
          <td>(</td>
          <td class="paramtype">DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ListType &amp;&nbsp;</td>
          <td class="paramname"> <em>swapped_edges</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps edges away from the (boundary) node associated with <em>dart</em> in such a way that when removing the edges that remain incident with the node, the boundary of the triangulation will be convex. This function is used as a first step in <a class="el" href="namespacettl.html#4c3b043409ba7cdf81b2735178e5515b">ttl::removeBoundaryNode</a><p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dart</em>&nbsp;</td><td>A CCW dart incident with the node</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#b90cf64bafd25ff741c1bcd993c07273">TraitsType::swapEdge</a> (DartType&amp; <em>dart</em>)<br>
 <b>Note:</b> Must be implemented such that <em>dart</em> is delivered back in a position as seen if it was glued to the edge when swapping (rotating) the edge CCW</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Assumes:</b></dt><dd><ul>
<li>The node associated with <em>dart</em> is at the boundary of the triangulation.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacettl.html#cc25203893aa640fe9f66b28d84e457d">ttl::swapEdgesAwayFromInteriorNode</a> </dd></dl>

<p>
Definition at line <a class="el" href="ttl_8h-source.html#l01728">1728</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="816c0b9687712b9a58225c46fbaa8446"></a><!-- doxytag: member="ttl::swapEdgeInList" ref="816c0b9687712b9a58225c46fbaa8446" args="(const typename DartListType::iterator &amp;it, DartListType &amp;elist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ttl::swapEdgeInList           </td>
          <td>(</td>
          <td class="paramtype">const typename DartListType::iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DartListType &amp;&nbsp;</td>
          <td class="paramname"> <em>elist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swap the the edge associated with iterator <em>it</em> and update affected darts in <em>elist</em> accordingly. The darts affected by the swap are those in the same quadrilateral. Thus, if one want to preserve one or more of these darts on should keep them in <em>elist</em>. 
<p>
Definition at line <a class="el" href="ttl_8h-source.html#l01817">1817</a> of file <a class="el" href="ttl_8h-source.html">ttl.h</a>.
</div>
</div><p>
<a class="anchor" name="3096f6756146df27c873c4ff3fe5a19f"></a><!-- doxytag: member="ttl::insertConstraint" ref="3096f6756146df27c873c4ff3fe5a19f" args="(DartType &amp;dstart, DartType &amp;dend, bool optimize_delaunay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DartType ttl::insertConstraint           </td>
          <td>(</td>
          <td class="paramtype">DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DartType &amp;&nbsp;</td>
          <td class="paramname"> <em>dend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>optimize_delaunay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts a constrained edge between two existing nodes in a triangulation. If the constraint falls on one or more existing nodes and this is detected by the predicate <code>TraitsType::orient2d</code>, which should return zero in this case, the constraint is split. Otherwise a degenerate triangle will be made along the constraint.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dstart</em>&nbsp;</td><td>A CCW dart with the start node of the constraint as the source node</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dend</em>&nbsp;</td><td>A CCW dart with the end node of the constraint as the source node</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optimize_delaunay</em>&nbsp;</td><td>If set to <code>true</code>, the resulting triangulation will be a <em>constrained</em> <em>Delaunay</em> <em>triangulation</em>. If set to <code>false</code>, the resulting triangulation will not necessarily be of constrained Delaunay type.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DartType</em>&nbsp;</td><td>A dart representing the constrained edge.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Requires:</b></dt><dd><ul>
<li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#ea241c2ba424c3c802fc0c54d6c74a0a">TraitsType::orient2d</a> (DartType&amp;, DartType&amp;, PointType&amp;)</li><li><a class="elRef" doxygen="tagfile_hed:../../halfedge_doc/html/" href="../../halfedge_doc/html/structhed_1_1TTLtraits.html#b90cf64bafd25ff741c1bcd993c07273">TraitsType::swapEdge</a> (DartType&amp;)</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Using:</b></dt><dd><ul>
<li><a class="el" href="namespacettl.html#190da335d29a65ce524868714ff3614c">ttl::optimizeDelaunay</a> if <em>optimize_delaunay</em> is set to <code>true</code> </li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Assumes:</b></dt><dd><ul>
<li>The constrained edge must be inside the existing triangulation (and it cannot cross the boundary of the triangulation). </li></ul>
</dd></dl>

<p>
Definition at line <a class="el" href="ttl__constr_8h-source.html#l00543">543</a> of file <a class="el" href="ttl__constr_8h-source.html">ttl_constr.h</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Wed Sep 19 15:14:45 2007 for ttl by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
